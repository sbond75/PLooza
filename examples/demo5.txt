// error: l foo = x in y;

// Only top-level code can use whereclauses for replacing IO effects.
// For example, this lambda can only have its `print` replaced by io.print (since it is in the `io` map part of the standard library) in a top-level (topmost) declaration (like `example2`).
l foo = x in print x;

// This is an error because the `where` applies to a function call `foo x` which is *not* top-level:
// l example1 = x in foo x where print is io.print;

// This is ok since it is top-level
foo "hi" where print is io.print;

// And if I do this...
l example2 = x in foo x;
// ...followed by:
example2 "hi" where print is io.print;
// Then this will work.


// This is ok at any level (not just top-level) because `bar` isn't from the `io` map:
l foo2 = x in bar x;
l example3 = x in foo2 x where bar is x in x;
// Error:
l example4 = x in foo2 x where bar is io.print;
// Error:
l example5 = x in example2 x where print is io.print;
// Error:
l example6 = x in example2 x;
// Error: variable `foo` is bound already (in body of `example2`):
l example6 = x in example2 x where foo is foo2;
