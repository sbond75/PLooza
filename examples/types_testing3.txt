// Based on "A Flock of Functions: Lambda Calculus and Combinatory Logic in JavaScript | Gabriel Lebec @ DevTalks" ( https://www.youtube.com/watch?v=6BnVo7EHO_8 )

// Calls a given function on itself.
l mockingbird = f in (f f); // causes infinite type checking loop, is normal, like Haskell

// Identity function: returns the input.
l id = x in x;

// This should equal the identity function.
///mockingbird id; // causes infinite type checking loop, is normal, like Haskell
//l res = mockingbird id;
//io.print (mockingbird id);

// Stack overflow:
//l omega = mockingbird mockingbird;

// Takes in two things and returns the first one.
l kestrel = a in (b in a); // aka "first"    // type: a->b->a

// This should equal 1.
kestrel 1 2;

// This should equal 2.
kestrel 2 kestrel;
//io.print (kestrel 2 kestrel);

// A function that returns 5 always regardless of its input.
l k5 = kestrel 5;
//io.print (k5 1);

// This should equal the mockingbird.
// TODO: fix parser bug.. `kestrel mockingbird id` should be acceptable instead of `(kestrel mockingbird id)` which requires parens
(kestrel mockingbird id);
//io.print (kestrel mockingbird id);

// This should equal the identity function.
(kestrel id mockingbird);
io.print ((kestrel id) mockingbird);
io.print (kestrel id mockingbird);

io.print id;


i x = 10;
i y = 20;
//io.print (kestrel id x);
//io.print (id 5);
// l kestrelIdX = kestrel id x;
// io.print kestrelIdX;
// io.print (kestrelIdX y);

io.print ((kestrel id x) y);
// `::` means "has type":
// (kestrel :: a->b->a) (id :: a->a) :: b->(a->a)
// (kestrel id x) :: a->a
// (kestrel id x y) :: int

//i y2 = kestrel id x y; // This should equal `y`.
//io.print y2;











// l first = x,y in x;
// l second = x,y in y;



// l test = io.print;
// l const1 = _ in 1;
// test const1;
